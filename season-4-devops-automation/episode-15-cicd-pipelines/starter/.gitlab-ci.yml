# KERNEL SHADOWS: Episode 15 — CI/CD Pipelines
# GitLab CI/CD Configuration with TODO
# Berlin, Germany (Day 29-30)
# Hans Müller, CCC — "Automate carefully. Test twice, deploy once."

# ============================================================================
# Pipeline Structure
# ============================================================================
#
# 1. test    → Linters, unit tests, security scan
# 2. build   → Build Docker image, push to registry
# 3. deploy  → Deploy to staging/production (manual approval)
#
# Triggers:
#   - Every push to any branch → test stage
#   - Push to main → test + build + deploy
#   - Merge requests → test only
#
# ============================================================================

# TODO 1: Определи stages (этапы pipeline)
# Подсказка:
# stages:
#   - test
#   - build
#   - deploy
#
# Stages выполняются последовательно. Jobs в одном stage — параллельно.
stages:
  - ???
  - ???
  - ???

# ============================================================================
# Global Variables
# ============================================================================

# TODO 2: Определи глобальные переменные
# Подсказка:
# variables:
#   DOCKER_IMAGE: registry.gitlab.com/operation-shadow/app
#   DOCKER_DRIVER: overlay2
#
# Переменные доступны во всех jobs
variables:
  DOCKER_IMAGE: ???
  DOCKER_DRIVER: ???
  DOCKER_TLS_CERTDIR: "/certs"

# TODO 3: Подключи Docker-in-Docker service
# Подсказка:
# services:
#   - docker:24-dind
#
# Docker-in-Docker позволяет build образов внутри CI/CD pipeline
services:
  - ???

# ============================================================================
# Stage 1: Test
# ============================================================================

# TODO 4: Создай job для shellcheck (linting)
# Подсказка:
# test:lint:
#   stage: test
#   image: koalaman/shellcheck-alpine:stable
#   script:
#     - echo "Running ShellCheck..."
#     - find . -name "*.sh" -exec shellcheck {} \;
#   tags:
#     - docker
#   allow_failure: false
#
# shellcheck — linter для bash скриптов
# allow_failure: false — pipeline упадёт если есть ошибки
test:lint:
  stage: ???
  image: ???
  script:
    - echo "Running ShellCheck..."
    - ???  # TODO: команда для поиска .sh файлов и запуска shellcheck
  tags:
    - docker
  allow_failure: ???  # false = обязательно должен пройти

# TODO 5: Создай job для unit tests
# Подсказка:
# test:unit:
#   stage: test
#   image: ubuntu:22.04
#   before_script:
#     - apt-get update -qq
#     - apt-get install -y -qq bash curl jq
#   script:
#     - echo "Running unit tests..."
#     - chmod +x tests/run_tests.sh
#     - ./tests/run_tests.sh
#   artifacts:
#     when: always
#     paths:
#       - tests/results.xml
#     expire_in: 1 week
#   tags:
#     - docker
#
# before_script — выполняется перед main script
# artifacts — сохраняет файлы после job (test results, build artifacts)
test:unit:
  stage: ???
  image: ???
  before_script:
    - apt-get update -qq
    - ???  # TODO: установить bash, curl, jq
  script:
    - echo "Running unit tests..."
    - chmod +x tests/run_tests.sh
    - ???  # TODO: запустить test скрипт
  artifacts:
    when: ???  # always = сохранить artifacts даже если job упал
    paths:
      - ???  # TODO: путь к test results
    expire_in: ???  # TODO: как долго хранить artifacts (1 week)
  tags:
    - docker

# TODO 6: Создай job для security scan (опционально)
# Подсказка:
# test:security:
#   stage: test
#   image: aquasec/trivy:latest
#   script:
#     - echo "Running security scan..."
#     - trivy fs --severity HIGH,CRITICAL --exit-code 1 .
#   allow_failure: true
#   tags:
#     - docker
#   only:
#     - main
#
# trivy — сканер уязвимостей для Docker images и filesystems
# allow_failure: true — не блокировать pipeline если найдены уязвимости
# only: [main] — запускать только на main ветке
test:security:
  stage: ???
  image: ???
  script:
    - echo "Running security scan..."
    - ???  # TODO: команда trivy
  allow_failure: ???  # true = предупреждение, не блокирует
  tags:
    - docker
  only:
    - ???  # TODO: только на main ветке

# ============================================================================
# Stage 2: Build
# ============================================================================

# TODO 7: Создай job для build Docker image
# Подсказка:
# build:docker:
#   stage: build
#   image: docker:24
#   before_script:
#     - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#   script:
#     - echo "Building Docker image..."
#     - docker build -t $DOCKER_IMAGE:$CI_COMMIT_SHA .
#     - docker build -t $DOCKER_IMAGE:latest .
#     - docker push $DOCKER_IMAGE:$CI_COMMIT_SHA
#     - docker push $DOCKER_IMAGE:latest
#   after_script:
#     - echo "Image pushed → $DOCKER_IMAGE:$CI_COMMIT_SHA"
#   tags:
#     - docker
#   only:
#     - main
#   dependencies:
#     - test:unit
#
# $CI_* — GitLab predefined variables (CI_COMMIT_SHA, CI_REGISTRY_USER, etc.)
# dependencies — job зависит от успеха test:unit
# only: [main] — build только на main ветке
build:docker:
  stage: ???
  image: ???
  before_script:
    - ???  # TODO: docker login (используй $CI_REGISTRY_USER, $CI_REGISTRY_PASSWORD, $CI_REGISTRY)
  script:
    - echo "Building Docker image..."
    - ???  # TODO: build образ с тегом $CI_COMMIT_SHA
    - ???  # TODO: build образ с тегом latest
    - ???  # TODO: push образ $CI_COMMIT_SHA
    - ???  # TODO: push образ latest
  after_script:
    - echo "Image pushed → $DOCKER_IMAGE:$CI_COMMIT_SHA"
  tags:
    - docker
  only:
    - ???  # TODO: только на main
  dependencies:
    - ???  # TODO: зависит от test:unit

# ============================================================================
# Stage 3: Deploy
# ============================================================================

# TODO 8: Создай job для deploy на staging
# Подсказка:
# deploy:staging:
#   stage: deploy
#   image: alpine:latest
#   before_script:
#     - apk add --no-cache openssh-client
#     - eval $(ssh-agent -s)
#     - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
#     - mkdir -p ~/.ssh
#     - chmod 700 ~/.ssh
#     - ssh-keyscan $STAGING_SERVER >> ~/.ssh/known_hosts
#   script:
#     - echo "Deploying to staging..."
#     - ssh deploy@$STAGING_SERVER "docker pull $DOCKER_IMAGE:$CI_COMMIT_SHA"
#     - ssh deploy@$STAGING_SERVER "docker stop operation-shadow-staging || true"
#     - ssh deploy@$STAGING_SERVER "docker rm operation-shadow-staging || true"
#     - ssh deploy@$STAGING_SERVER "docker run -d --name operation-shadow-staging -p 8080:80 $DOCKER_IMAGE:$CI_COMMIT_SHA"
#     - echo "✓ Deployed to staging → $STAGING_SERVER"
#   environment:
#     name: staging
#     url: https://staging.operation-shadow.net
#   tags:
#     - docker
#   only:
#     - development
#   when: manual
#
# SSH deployment workflow:
#   1. Setup SSH (add private key, scan host keys)
#   2. Pull Docker image на remote server
#   3. Stop old container
#   4. Remove old container
#   5. Run new container
#
# when: manual — требует ручного подтверждения в GitLab UI
deploy:staging:
  stage: ???
  image: ???
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ???  # TODO: ssh-keyscan для добавления host key
  script:
    - echo "Deploying to staging..."
    - ???  # TODO: docker pull на remote server
    - ???  # TODO: stop старого контейнера (|| true = не падать если не существует)
    - ???  # TODO: remove старого контейнера
    - ???  # TODO: run нового контейнера с портом 8080:80
    - echo "✓ Deployed to staging → $STAGING_SERVER"
  environment:
    name: ???  # staging
    url: ???  # URL staging окружения
  tags:
    - docker
  only:
    - ???  # TODO: только на development ветке
  when: ???  # manual = требует ручного подтверждения

# TODO 9: Создай job для deploy на production
# Подсказка:
# deploy:production:
#   stage: deploy
#   image: alpine:latest
#   before_script:
#     - apk add --no-cache openssh-client curl
#     - eval $(ssh-agent -s)
#     - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
#     - mkdir -p ~/.ssh
#     - chmod 700 ~/.ssh
#     - ssh-keyscan $PRODUCTION_SERVER >> ~/.ssh/known_hosts
#   script:
#     - echo "⚠️  Deploying to PRODUCTION..."
#     - ssh deploy@$PRODUCTION_SERVER "docker pull $DOCKER_IMAGE:$CI_COMMIT_SHA"
#     # Blue-green deployment (zero downtime)
#     - ssh deploy@$PRODUCTION_SERVER "docker stop operation-shadow-old || true"
#     - ssh deploy@$PRODUCTION_SERVER "docker rename operation-shadow operation-shadow-old || true"
#     - ssh deploy@$PRODUCTION_SERVER "docker run -d --name operation-shadow -p 80:80 $DOCKER_IMAGE:$CI_COMMIT_SHA"
#     # Health check
#     - sleep 10
#     - curl -f http://$PRODUCTION_SERVER/health || exit 1
#     # Cleanup old container
#     - ssh deploy@$PRODUCTION_SERVER "docker rm operation-shadow-old || true"
#     - echo "✓ Deployed to production → $PRODUCTION_SERVER"
#   environment:
#     name: production
#     url: https://operation-shadow.net
#   tags:
#     - docker
#   only:
#     - main
#   when: manual
#   dependencies:
#     - build:docker
#
# Blue-green deployment:
#   1. Старый контейнер переименовывается в operation-shadow-old
#   2. Новый контейнер запускается с именем operation-shadow
#   3. Health check проверяет что новый работает
#   4. Старый контейнер удаляется
#   5. Если health check упал — можно быстро вернуть старый
deploy:production:
  stage: ???
  image: ???
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ???  # TODO: ssh-keyscan PRODUCTION_SERVER
  script:
    - echo "⚠️  Deploying to PRODUCTION..."
    - ???  # TODO: docker pull на production
    # Blue-green deployment
    - ???  # TODO: stop old container
    - ???  # TODO: rename current → old
    - ???  # TODO: run new container (port 80:80)
    # Health check
    - sleep 10
    - ???  # TODO: curl healthcheck (exit 1 если упал)
    # Cleanup
    - ???  # TODO: remove old container
    - echo "✓ Deployed to production → $PRODUCTION_SERVER"
  environment:
    name: ???  # production
    url: ???  # URL production
  tags:
    - docker
  only:
    - ???  # main
  when: ???  # manual
  dependencies:
    - ???  # build:docker

# ============================================================================
# СПРАВКА: Как использовать после заполнения TODO
#
# 1. Добавь .gitlab-ci.yml в git:
#    git add .gitlab-ci.yml
#    git commit -m "Add CI/CD pipeline"
#    git push
#
# 2. GitLab автоматически обнаружит файл и запустит pipeline
#
# 3. Настрой CI/CD Variables в GitLab:
#    Settings → CI/CD → Variables:
#    - CI_REGISTRY_USER (GitLab username)
#    - CI_REGISTRY_PASSWORD (Personal access token)
#    - SSH_PRIVATE_KEY (SSH ключ для deployment)
#    - STAGING_SERVER (IP или hostname staging server)
#    - PRODUCTION_SERVER (IP или hostname production server)
#
# 4. Мониторь pipeline:
#    GitLab → CI/CD → Pipelines
#
# 5. Manual deployment:
#    - Pipeline дойдёт до deploy stage
#    - Нажми "Play" кнопку для manual jobs
#
# ============================================================================
# ВОПРОСЫ ДЛЯ ПОНИМАНИЯ:
#
# 1. Что такое stages?
#    → Этапы pipeline (test → build → deploy)
#    → Stages выполняются последовательно
#    → Jobs внутри stage выполняются параллельно
#
# 2. В чём разница между script, before_script, after_script?
#    → before_script — выполняется перед main script (setup)
#    → script — main logic job
#    → after_script — выполняется после script (cleanup, всегда)
#
# 3. Зачем artifacts?
#    → Сохранить файлы после job (test results, build outputs)
#    → Передать данные между jobs
#    → expire_in — автоочистка старых artifacts
#
# 4. Что делает dependencies?
#    → Определяет зависимости между jobs
#    → build:docker зависит от test:unit — не запустится если test упал
#
# 5. Зачем when: manual?
#    → Требует ручного подтверждения в GitLab UI
#    → КРИТИЧНО для production deployment (не деплоить автоматически!)
#
# 6. Что такое Blue-green deployment?
#    → Zero-downtime deployment strategy
#    → Запускаешь новую версию параллельно со старой
#    → Проверяешь healthcheck
#    → Переключаешь traffic на новую
#    → Удаляешь старую
#
# 7. Что такое only и except?
#    → Фильтры для запуска jobs
#    → only: [main] — запускать только на main ветке
#    → except: [development] — НЕ запускать на development
#
# 8. Зачем allow_failure?
#    → true — job может упасть, pipeline продолжится (warning)
#    → false — job упал = весь pipeline упал
#    → Используй для опциональных проверок (security scan)
#
# ============================================================================
# GitLab CI/CD Best Practices (Hans's notes):
#
# ✅ DO:
# - Используй stages для организации pipeline
# - Добавляй before_script для setup
# - Сохраняй test results через artifacts
# - Используй only/except для фильтрации веток
# - Manual approval для production
# - Healthcheck после deployment
# - Храни secrets в GitLab Variables (НЕ в .gitlab-ci.yml!)
# - Используй Docker-in-Docker для build
# - Pin версии images (docker:24, не docker:latest)
#
# ❌ DON'T:
# - НЕ храни secrets в .gitlab-ci.yml (используй Variables)
# - НЕ деплой в production без manual approval
# - НЕ деплой без healthcheck
# - НЕ используй latest tag для images в production
# - НЕ забывай про rollback strategy
# - НЕ запускай тяжёлые tests на каждый commit (используй only)
#
# ============================================================================
# GitLab Predefined Variables (наиболее полезные):
#
# $CI_COMMIT_SHA          — SHA текущего commit
# $CI_COMMIT_REF_NAME     — Имя ветки или тега
# $CI_COMMIT_AUTHOR       — Автор commit
# $CI_PIPELINE_ID         — ID текущего pipeline
# $CI_PROJECT_NAME        — Имя проекта
# $CI_REGISTRY            — GitLab Container Registry URL
# $CI_REGISTRY_USER       — Username для registry
# $CI_REGISTRY_PASSWORD   — Password для registry
#
# Полный список: https://docs.gitlab.com/ee/ci/variables/predefined_variables.html
#
# ============================================================================
# Pipeline Flow Diagram:
#
# ┌─────────────────────────────────────────────────────────────┐
# │  git push → GitLab                                          │
# └────────────────────┬────────────────────────────────────────┘
#                      ▼
#     ┌────────────────────────────────────┐
#     │  STAGE 1: test                     │
#     ├────────────────┬───────────────────┤
#     │  test:lint     │  test:unit        │  (parallel)
#     │  test:security │                   │
#     └────────────────┴───────────────────┘
#                      ▼
#     ┌────────────────────────────────────┐
#     │  STAGE 2: build                    │
#     ├────────────────────────────────────┤
#     │  build:docker                      │
#     └────────────────────────────────────┘
#                      ▼
#     ┌────────────────────────────────────┐
#     │  STAGE 3: deploy                   │
#     ├────────────────┬───────────────────┤
#     │  deploy:staging│  deploy:production│  (manual)
#     └────────────────┴───────────────────┘
#                      ▼
#     ┌────────────────────────────────────┐
#     │  Production running! ✅             │
#     └────────────────────────────────────┘
#
# ============================================================================
# Hans Müller: "Automate carefully. Test twice, deploy once.
#               CI/CD is not magic — it's discipline."
# ============================================================================

