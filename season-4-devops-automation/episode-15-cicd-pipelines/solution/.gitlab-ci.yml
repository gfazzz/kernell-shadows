# KERNEL SHADOWS: Episode 15 — CI/CD Pipelines
# GitLab CI/CD Configuration
# Berlin, Germany (Day 29-30)
# Hans Müller, CCC — "Automate carefully. Test twice, deploy once."

# ============================================================================
# Pipeline Structure
# ============================================================================
#
# 1. test    → Run linters, unit tests
# 2. build   → Build Docker image
# 3. deploy  → Deploy to production (manual approval)
#
# Triggers:
#   - Every push to any branch → test
#   - Push to main → test + build + deploy (manual)
#   - Merge requests → test only
#
# ============================================================================

stages:
  - test
  - build
  - deploy

# ============================================================================
# Global Variables
# ============================================================================

variables:
  DOCKER_IMAGE: registry.gitlab.com/operation-shadow/app
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# Use Docker-in-Docker service for builds
services:
  - docker:24-dind

# ============================================================================
# Stage 1: Test
# ============================================================================

test:lint:
  stage: test
  image: koalaman/shellcheck-alpine:stable
  script:
    - echo "Running ShellCheck..."
    - find . -name "*.sh" -exec shellcheck {} \;
  tags:
    - docker
  allow_failure: false

test:unit:
  stage: test
  image: ubuntu:22.04
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq bash curl jq
  script:
    - echo "Running unit tests..."
    - chmod +x tests/run_tests.sh
    - ./tests/run_tests.sh
  artifacts:
    when: always
    reports:
      junit: tests/results.xml
    expire_in: 1 week
  tags:
    - docker

test:security:
  stage: test
  image: aquasec/trivy:latest
  script:
    - echo "Running security scan..."
    - trivy fs --severity HIGH,CRITICAL --exit-code 1 .
  allow_failure: true
  tags:
    - docker
  only:
    - main
    - development

# ============================================================================
# Stage 2: Build
# ============================================================================

build:docker:
  stage: build
  image: docker:24
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - docker build -t $DOCKER_IMAGE:$CI_COMMIT_SHA .
    - docker build -t $DOCKER_IMAGE:latest .
    - docker push $DOCKER_IMAGE:$CI_COMMIT_SHA
    - docker push $DOCKER_IMAGE:latest
  after_script:
    - echo "Image pushed → $DOCKER_IMAGE:$CI_COMMIT_SHA"
  tags:
    - docker
  only:
    - main
  dependencies:
    - test:unit

build:report:
  stage: build
  image: alpine:latest
  script:
    - echo "========================================="
    - echo "BUILD REPORT"
    - echo "========================================="
    - echo "Commit: $CI_COMMIT_SHA"
    - echo "Branch: $CI_COMMIT_REF_NAME"
    - echo "Author: $CI_COMMIT_AUTHOR"
    - echo "Pipeline: $CI_PIPELINE_ID"
    - echo "Image: $DOCKER_IMAGE:$CI_COMMIT_SHA"
    - echo "========================================="
  artifacts:
    paths:
      - build_report.txt
    expire_in: 1 month
  tags:
    - docker
  only:
    - main

# ============================================================================
# Stage 3: Deploy
# ============================================================================

deploy:staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $STAGING_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "Deploying to staging..."
    - ssh deploy@$STAGING_SERVER "docker pull $DOCKER_IMAGE:$CI_COMMIT_SHA"
    - ssh deploy@$STAGING_SERVER "docker stop operation-shadow-staging || true"
    - ssh deploy@$STAGING_SERVER "docker rm operation-shadow-staging || true"
    - ssh deploy@$STAGING_SERVER "docker run -d --name operation-shadow-staging -p 8080:80 $DOCKER_IMAGE:$CI_COMMIT_SHA"
    - echo "✓ Deployed to staging → $STAGING_SERVER"
  environment:
    name: staging
    url: https://staging.operation-shadow.net
  tags:
    - docker
  only:
    - development
  when: manual

deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $PRODUCTION_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "⚠️  Deploying to PRODUCTION..."
    - ssh deploy@$PRODUCTION_SERVER "docker pull $DOCKER_IMAGE:$CI_COMMIT_SHA"
    # Blue-green deployment (zero downtime)
    - ssh deploy@$PRODUCTION_SERVER "docker stop operation-shadow-old || true"
    - ssh deploy@$PRODUCTION_SERVER "docker rename operation-shadow operation-shadow-old || true"
    - ssh deploy@$PRODUCTION_SERVER "docker run -d --name operation-shadow -p 80:80 $DOCKER_IMAGE:$CI_COMMIT_SHA"
    # Health check
    - sleep 10
    - curl -f http://$PRODUCTION_SERVER/health || exit 1
    # Cleanup old container
    - ssh deploy@$PRODUCTION_SERVER "docker rm operation-shadow-old || true"
    - echo "✓ Deployed to production → $PRODUCTION_SERVER"
  environment:
    name: production
    url: https://operation-shadow.net
  tags:
    - docker
  only:
    - main
  when: manual
  dependencies:
    - build:docker

deploy:rollback:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Rolling back production..."
    - ssh deploy@$PRODUCTION_SERVER "docker stop operation-shadow"
    - ssh deploy@$PRODUCTION_SERVER "docker rename operation-shadow-old operation-shadow || exit 1"
    - ssh deploy@$PRODUCTION_SERVER "docker start operation-shadow"
    - echo "✓ Rollback complete"
  environment:
    name: production
    url: https://operation-shadow.net
  tags:
    - docker
  only:
    - main
  when: manual

# ============================================================================
# Notifications (optional)
# ============================================================================

notify:success:
  stage: .post
  image: curlimages/curl:latest
  script:
    - echo "Sending success notification..."
    - |
      curl -X POST $SLACK_WEBHOOK \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"✅ Pipeline SUCCESS: $CI_PROJECT_NAME ($CI_COMMIT_REF_NAME) by $CI_COMMIT_AUTHOR\"}"
  only:
    - main
  when: on_success

notify:failure:
  stage: .post
  image: curlimages/curl:latest
  script:
    - echo "Sending failure notification..."
    - |
      curl -X POST $SLACK_WEBHOOK \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"❌ Pipeline FAILED: $CI_PROJECT_NAME ($CI_COMMIT_REF_NAME) — Check GitLab\"}"
  only:
    - main
  when: on_failure

# ============================================================================
# Hans Müller's CI/CD Philosophy:
#
# "Automate carefully. Test twice, deploy once."
#
# Pipeline guarantees:
#   ✅ Code is linted (shellcheck)
#   ✅ Tests pass before build
#   ✅ Security scan before deployment
#   ✅ Manual approval for production
#   ✅ Zero-downtime blue-green deployment
#   ✅ Easy rollback if issues
#
# CI/CD secrets (configure in GitLab Settings → CI/CD → Variables):
#   - CI_REGISTRY_USER
#   - CI_REGISTRY_PASSWORD
#   - SSH_PRIVATE_KEY
#   - STAGING_SERVER
#   - PRODUCTION_SERVER
#   - SLACK_WEBHOOK
#
# "Fast feedback. Safe deployment. That's CI/CD done right."
# ============================================================================


